<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jose Diaz-Gonzalez</title>
    <description>Developer, Accidental Ops Guy, and CakePHP Core Developer</description>
    <link>http://josediazgonzalez.com/</link>
    <atom:link href="http://josediazgonzalez.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 10 Dec 2015 02:06:11 +0000</pubDate>
    <lastBuildDate>Thu, 10 Dec 2015 02:06:11 +0000</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Customizing your Application Template</title>
        <description>&lt;p&gt;CakePHP has long had the ability to generate new projects via the &lt;code&gt;bake&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;// my custom cat project
cake bake project camila
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the above command, CakePHP would scaffold out all the necessary directories and files for a new project (&lt;code&gt;AppModel&lt;/code&gt;, &lt;code&gt;AppController&lt;/code&gt;, configuration files, etc.). You could even customize this using a &lt;a href=&quot;http://book.cakephp.org/2.0/en/console-and-shells/code-generation-with-bake.html#for-baking-custom-projects&quot;&gt;bake skeleton&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;// be sure to copy in my cat project instead
cake bake project camila --skel Console/Templates/cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In CakePHP 3, this feature of bake has mostly gone away in favor of using &lt;code&gt;composer&lt;/code&gt; to handle scaffolding. When starting a new project, you typically do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer create-project --prefer-dist cakephp/app camila
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Composer’s &lt;code&gt;create-project&lt;/code&gt; command is great for scaffolding out new projects and is used for a variety of things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Framework-specific application repos&lt;/li&gt;
  &lt;li&gt;Framework-specific plugin modules&lt;/li&gt;
  &lt;li&gt;Generic composer packages&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The great thing about this command is that the “skeletons” are in all actually composer packages. This means it is extremely easy to use your normal distribution methods to release new versions of the package, something the CakePHP project has done with it’s &lt;a href=&quot;https://github.com/cakephp/app&quot;&gt;cakephp/app&lt;/a&gt; repository.&lt;/p&gt;

&lt;p&gt;Now, as a side-effect of this, you can &lt;em&gt;*also*&lt;/em&gt; fork any existing composer skeleton and add your own customizations. For instance, lets say we wanted to have a composer skeleton with the following plugins installed automatically:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/josegonzalez/cakephp-upload&quot;&gt;josegonzalez/upload&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/friendsofcake/crud&quot;&gt;friendsofcake/crud&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/friendsofcake/crud-view&quot;&gt;friendsofcake/crud-view&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/thephpleague/fractal&quot;&gt;league/fractal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/usemuffin/trash&quot;&gt;usemuffin/trash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can simply do the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Fork the &lt;a href=&quot;https://github.com/cakephp/app&quot;&gt;cakephp/app&lt;/a&gt; repository on github.&lt;/li&gt;
  &lt;li&gt;Change the name in the fork’s composer.json to &lt;code&gt;myname/app&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Add any custom requirements to the &lt;code&gt;composer.json&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Make a new tag/release on github.&lt;/li&gt;
  &lt;li&gt;Add it to &lt;a href=&quot;https://packagist.org&quot;&gt;packagist.org&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pretty simple. We can now use this project as a baseline for all of our new CakePHP projects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer create-project --prefer-dist myname/app camila
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from adding custom plugins, one thing you may want to look is customizing the initial project files. For instance, if you find yourself constantly adding certain helper classes, or modifying how configuration is loaded, this is a good chance to improve the base state of your initial applications.&lt;/p&gt;

&lt;p&gt;As every project is slightly different, please try and keep application-specific enhancements to a minimum, as they may only serve as a hindrance when using your skeleton. No one wants to setup an app and then spend an hour deleting useless code :)&lt;/p&gt;

&lt;p&gt;For those of you who are interested in such a project, &lt;a href=&quot;https://github.com/loadsys/CakePHP-Skeleton&quot;&gt;here is an advanced skeleton&lt;/a&gt; from the good folks at &lt;a href=&quot;https://www.loadsys.com/&quot;&gt;Loadsys Web Strategies&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/09/customizing-your-app-template/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/09/customizing-your-app-template/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>composer</category>
        
        <category>create-project</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Debugging Data in CakePHP 3</title>
        <description>&lt;p&gt;Since upgrading to CakePHP 3, you may have noticed a few changes. Yes, it’s faster, better for your cholesterol, and likely good for your Vitamin D intake&lt;sup&gt;&lt;a href=&quot;If you work less because you are working smarter, you are more likely to go outside and get some Sun. Remember to do that every so often!&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. However, what I’m referring to is the nicer debugging output.&lt;/p&gt;

&lt;p&gt;Typically when you debug an object in PHP, you use something like &lt;code&gt;print_r()&lt;/code&gt; or &lt;code&gt;var_dump()&lt;/code&gt;. With scalar types - &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; - you’ll get a pretty simple representation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;php &amp;gt; $i = 1;
php &amp;gt; var_dump($i);
int(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats really all you need. But if you try doing the same thing with an object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;class Person
{
  public $name = &#39;Alex Super Tramp&#39;;
  public $age = 100;
  private $property = &#39;property&#39;;
}

// debugging
php &amp;gt; $p = new Person;
php &amp;gt; var_dump($p);
class Person#1 (3) {
  public $name =&amp;gt;
  string(16) &quot;Alex Super Tramp&quot;
  public $age =&amp;gt;
  int(100)
  private $property =&amp;gt;
  string(8) &quot;property&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You get pretty verbose output on that object. For simple objects, this might not be so bad, but the problem is compounded when you are trying to debug a &lt;code&gt;Table&lt;/code&gt; class, or a &lt;code&gt;Controller&lt;/code&gt; etc. Fortunately, in CakePHP 3 we take advantage of a special magic method, &lt;code&gt;__debugInfo()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;magic-methods-to-the-rescue&quot;&gt;Magic Methods to the rescue&lt;/h2&gt;

&lt;p&gt;Since PHP 5.6, you can add the method &lt;code&gt;__debugInfo()&lt;/code&gt; to any class. When instances of said class are passed through &lt;code&gt;var_dump()&lt;/code&gt;, PHP will automatically use the &lt;code&gt;array&lt;/code&gt; returned by this method to display debug info about that instance.&lt;/p&gt;

&lt;p&gt;If the method is omitted, PHP will fallback to outputting &lt;em&gt;all&lt;/em&gt; properties in that instance. Here is a lovely example of this in action.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;class Person
{
  public $name = &#39;Alex Super Tramp&#39;;
  public $age = 100;
  private $property = &#39;property&#39;;
  public function __debugInfo()
  {
    return [&#39;name&#39; =&amp;gt; $this-&amp;gt;name];
  }
}

// debugging
php &amp;gt; $p = new Person;
php &amp;gt; var_dump($p);
object Person#1 (1) {
  [&quot;name&quot;] =&amp;gt;
  string(16) &quot;Alex Super Tramp&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fancy, right? Remember, while CakePHP &lt;em&gt;does&lt;/em&gt; support this feature automatically in 5.6, users of older PHP versions will fallback to the old, yucky data dump.&lt;/p&gt;

&lt;h2 id=&quot;how-this-affects-you&quot;&gt;How this affects you&lt;/h2&gt;

&lt;p&gt;There are a few places where &lt;code&gt;__debugInfo()&lt;/code&gt; has been useful:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Form&lt;/code&gt; instances output metadata about the schema, errors, and validation rules.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ResultSet&lt;/code&gt; instances output the query that is executed.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Cell&lt;/code&gt; objects will output the environment in which they were created (view layer as well as the current request/response objects).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Entities&lt;/code&gt; will output a plethora of data regarding the current state of the entity. Useful for seeing if the entity is new or has been changed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You’re also quite welcome to add your own &lt;code&gt;__debugInfo()&lt;/code&gt; methods to custom classes. For those of you who are curious, I definitely recommend looking at the list of &lt;a href=&quot;https://secure.php.net/manual/en/language.oop5.magic.php&quot;&gt;PHP Magic Methods&lt;/a&gt;, which might just be handy&lt;sup&gt;&lt;a href=&quot;My current favorite magic method is the `__invoke()` method :)&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; in a pinch!&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Tue, 08 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/08/debugging-data-in-cakephp-3/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/08/debugging-data-in-cakephp-3/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>magic-methods</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Error Handling in CakePHP 3</title>
        <description>&lt;p&gt;In CakePHP, you can attach custom error and exception handlers. The default one displays a stack trace in debug mode, and a set of http errors when debug is off. That’s nice and all, but sometimes you need to know when your users are encountering errors, and since you aren’t psychic, we need to store those somewhere. Thankfully, there are quite a few services that allow us to track bugs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://airbrake.io/&quot;&gt;Airbrake&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bugsnag.com/&quot;&gt;Bugsnag&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://opbeat.com/&quot;&gt;Opbeat&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One annoying thing about error/exception handling in CakePHP is needing to attach two handlers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// in your config/bootstrap.php
$isCli = php_sapi_name() === &#39;cli&#39;;
if ($isCli) {
    (new ConsoleErrorHandler(Configure::consume(&#39;Error&#39;)))-&amp;gt;register();
} else {
    (new ErrorHandler(Configure::consume(&#39;Error&#39;)))-&amp;gt;register();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ConsoleErrorHandler&lt;/code&gt;: For cli-based exceptions&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;: For web-based exceptions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is necessary as the exception handler needs to render the exception information differently; the web error handler might want to use json for responses, or show an html message with an interactive stacktrace.&lt;/p&gt;

&lt;p&gt;You &lt;em&gt;also&lt;/em&gt; have to have two methods in your handlers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;handleError&lt;/code&gt;: For PHP Errors. PHP 7 does some &lt;a href=&quot;https://secure.php.net/manual/en/language.errors.php7.php&quot;&gt;magic&lt;/a&gt; to make these catchable, so perhaps this one will go away someday.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;handleException&lt;/code&gt;: For thrown Exception instances.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rather than implement all error handling logic twice, we’ll go the trait-based route.&lt;/p&gt;

&lt;h2 id=&quot;traits&quot;&gt;Traits&lt;/h2&gt;

&lt;p&gt;Traits are composable units of behavior. They are similar to CakePHP Behaviors, though built into the PHP Core. They come in handy for exception handling in CakePHP as it becomes easy to implement the core logic of capturing an exception and just using that in multiple classes.&lt;/p&gt;

&lt;p&gt;Below is a trait for the &lt;code&gt;Bugsnag&lt;/code&gt; service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Error\Bugsnag;

use Bugsnag_Client;
use Cake\Core\Configure;
use Exception;

trait BugsnagTrait
{

    public function handleError($code, $description, $file = null, $line = null, $context = null)
    {
        $client = $this-&amp;gt;client();
        if ($client) {
            $client-&amp;gt;errorHandler($code, $description, $file, $line);
        }

        return parent::handleError($code, $description, $file, $line, $context);
    }

    public function handleException(Exception $exception)
    {
        $client = $this-&amp;gt;client();
        if ($client) {
            $client-&amp;gt;notifyException($exception);
        }

        return parent::handleException($exception);
    }

    protected function client()
    {
        $apiKey = Configure::read(&#39;Bugsnag.apiKey&#39;);
        if (!$apiKey &amp;amp;&amp;amp; defined(&#39;BUGSNAG_API_KEY&#39;)) {
            $apiKey = BUGSNAG_API_KEY;
        }

        if (!$apiKey) {
            return null;
        }

        $client = null;
        if ($apiKey) {
            $client = new Bugsnag_Client($apiKey);
            $config = Configure::read(&#39;Bugsnag.config&#39;);
            foreach ($config as $key =&amp;gt; $value) {
                if (method_exists($client, $key)) {
                    $client-&amp;gt;$key($value);
                }
            }
        }

        return $client;
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is what my &lt;code&gt;ErrorHandler&lt;/code&gt; looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Error\Bugsnag;

use App\Error\Bugsnag\BugsnagTrait;
use Cake\Error\ErrorHandler as CoreErrorHandler;

class ErrorHandler extends CoreErrorHandler
{
    use BugsnagTrait;
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how the &lt;code&gt;ErrorHandler&lt;/code&gt; class itself is devoid of any “real” logic? I’ve pushed all the heavy-lifting into the trait and then just ensured my &lt;code&gt;ErrorHandler&lt;/code&gt; extends the CakePHP core &lt;code&gt;ErrorHandler&lt;/code&gt;. Similarly, my &lt;code&gt;ConsoleErrorHandler&lt;/code&gt; is quite empty as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Error\Bugsnag;

use App\Error\Bugsnag\BugsnagTrait;
use Cake\Console\ConsoleErrorHandler as CoreConsoleErrorHandler;

class ConsoleErrorHandler extends CoreConsoleErrorHandler
{
    use BugsnagTrait;
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;homework-time&quot;&gt;Homework time&lt;/h2&gt;

&lt;p&gt;While the logic I implemented is fairly easy to understand, it may also not give the full picture around the exception. For instance, many error collection services provide the ability to add extra metadata to an error, such as the user that was signed in, or client information such as operating system version. &lt;code&gt;ExceptionRenderer&lt;/code&gt; instances can have access to this information using their &lt;code&gt;_getController&lt;/code&gt; methods, and it wouldn’t be too much work to copy that logic into your &lt;code&gt;ErrorHandler&lt;/code&gt; to add extra metadata to the request.&lt;/p&gt;

&lt;p&gt;I recommend customizing the error handler to fit your needs - adding metadata, or perhaps using a different service - and seeing what helps you find, replicate, and fix bugs your automated testing didn’t catch.&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/07/error-handling-in-cakephp-3/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/07/error-handling-in-cakephp-3/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>errors</category>
        
        <category>exceptions</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Invoking Callable Classes</title>
        <description>&lt;p&gt;CakePHP has offered the use of callables for invoking related logic since 2.x with the event system. They are great for expressing self-contained pieces of logic, but not so much for avoiding spaghetti code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;eventManager()-&amp;gt;on(&#39;event&#39;, function (\Cake\Event\Event $event) {
    // complex logic here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This only gets worse in CakePHP 3, where you now have to deal with formatters, custom rules, and other such niceties that are easier to handle via callbacks.&lt;/p&gt;

&lt;p&gt;One other drawback is that your code is no longer testable in isolation. You need to execute the enclosing block in order to even try to trigger the anonymous function. Thankfully, callables can be classes!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;use \Cake\Event\Event;
class SomeCallable
{
    public function __invoke(Event $event)
    {
        // complex logic here
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since PHP 5.4, we also have the &lt;code&gt;Callable&lt;/code&gt; typehint, which you can use in your own functions when interacting with either invokable classes or anonymous functions.&lt;/p&gt;

&lt;p&gt;Some notes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I try and place my callables in a logical namespace. Formatters go in &lt;code&gt;\App\Table\Formatters&lt;/code&gt;. Event handlers go in &lt;code&gt;\App\Event\Handlers&lt;/code&gt;. You get the idea.&lt;/li&gt;
  &lt;li&gt;You can pass in the callable by sending in an instance of that class. &lt;code&gt;__invoke&lt;/code&gt; will be run automatically.&lt;/li&gt;
  &lt;li&gt;I like adding a &lt;code&gt;run&lt;/code&gt; or &lt;code&gt;perform&lt;/code&gt; method that calls the &lt;code&gt;__invoke&lt;/code&gt; method. This makes it easy for me to reuse the class in non-callable situations.&lt;/li&gt;
  &lt;li&gt;You can test these just like any other class, or refactor your long anonymous function into a set of helper methods to simplify readability.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 06 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/06/invoking-callable-classes/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/06/invoking-callable-classes/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>callables</category>
        
        <category>events</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Uploading files and images with CakePHP 3</title>
        <description>&lt;p&gt;I’ve been working for years on upload plugins. CakePHP 1.2 users might remember MeioUpload - such a good plugin, it did &lt;em&gt;all&lt;/em&gt; the things. Which ended up being a bad move for maintainability. Something I took to heart when I worked on other alternatives, and when I finally wrote my &lt;a href=&quot;https://github.com/josegonzalez/cakephp-upload&quot;&gt;CakePHP Upload&lt;/a&gt; plugin. Until recently however, it supported only 2.x, and in this post-3.0 world, this just wouldn’t cut it.&lt;/p&gt;

&lt;p&gt;If you are using CakePHP 3, there have been a &lt;a href=&quot;https://github.com/WyriHaximus/FlyPie&quot;&gt;few&lt;/a&gt; &lt;a href=&quot;https://github.com/josbeir/image&quot;&gt;different&lt;/a&gt; &lt;a href=&quot;https://github.com/davidyell/CakePHP3-Proffer&quot;&gt;upload&lt;/a&gt; &lt;a href=&quot;https://github.com/Xety/Cake3-Upload&quot;&gt;plugins&lt;/a&gt;. In my mind, the &lt;a href=&quot;https://github.com/davidyell/CakePHP3-Proffer&quot;&gt;Proffer&lt;/a&gt; plugin is the spiritual successor to the 2.x Upload plugin. If you need something more or less drop-in, I recommend looking into it. But this post isn’t about the Proffer plugin, but rather the new version of my &lt;a href=&quot;https://github.com/josegonzalez/cakephp-upload&quot;&gt;own upload plugin&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;focus&quot;&gt;Focus&lt;/h2&gt;

&lt;p&gt;One thing I hated about the old plugin version is the fact that I was manually handling image thumbnails. There are plenty &lt;a href=&quot;https://github.com/avalanche123/Imagine&quot;&gt;of&lt;/a&gt; &lt;a href=&quot;https://github.com/Gregwar/Image&quot;&gt;awesome&lt;/a&gt; &lt;a href=&quot;https://github.com/Intervention/image&quot;&gt;packages&lt;/a&gt; to handle this already. Upload did it in a hacky way, with interpolated php logic coming from a regex-parsed string. And only sometimes did it work. And anything advanced, like adding a watermark, was mostly impossible. Sad panda.&lt;/p&gt;

&lt;p&gt;If you wanted to upload a file to S3, that was impossible without further work. Handling local files required a hacky behavior. Quite annoying when really the code changes should have been minimal.&lt;/p&gt;

&lt;p&gt;The other thing is that it was hard to test the code. So many codepaths to handle complex logic that honestly didn’t need to be there.&lt;/p&gt;

&lt;p&gt;So with the 3.x plugin, I’ve resolved to the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Only add code with 100% unit test coverage.&lt;/li&gt;
  &lt;li&gt;Stick to file uploading only.&lt;/li&gt;
  &lt;li&gt;Use external libraries for handling file storage.&lt;/li&gt;
  &lt;li&gt;Remove code that wasn’t strictly related to file uploading, like validation or image manipulation.&lt;/li&gt;
  &lt;li&gt;Provide class-based entry points into the lifecycle of a file upload.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;uploading-a-file&quot;&gt;Uploading a file&lt;/h2&gt;

&lt;p&gt;First install the thing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require josegonzalez/cakephp-upload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then load it in your &lt;code&gt;config/bootstrap.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;Plugin::load(&#39;Josegonzalez/Upload&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a sample &lt;code&gt;UsersTable&lt;/code&gt; that implements file uploading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Model\Table;

use App\Model\Entity\User;
use Cake\ORM\Table;

class UsersTable extends Table
{

    public function initialize(array $config)
    {
        $this-&amp;gt;table(&#39;users&#39;);
        $this-&amp;gt;displayField(&#39;name&#39;);
        $this-&amp;gt;primaryKey(&#39;id&#39;);
        $this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
            &#39;photo&#39;,
        ]);
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty basic. It will upload anything to the path &lt;code&gt;webroot/files/Users/photo/ID&lt;/code&gt;, and save metadata about the file to the &lt;code&gt;photo&lt;/code&gt; field. We still have a few of the same config options, with many of the same defaults. For instance, we may wish to change the upload path to be outside of &lt;code&gt;webroot&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39; =&amp;gt; [
        &#39;path&#39; =&amp;gt; &#39;static{DS}{model}{DS}{field}{DS}{primaryKey}&#39;,
    ],
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also save metadata about the file upload to three fields, &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, and &lt;code&gt;type&lt;/code&gt;. We can customize those just as easily:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39; =&amp;gt; [
        &#39;fields&#39; =&amp;gt; [
            &#39;dir&#39; =&amp;gt; &#39;photo_dir&#39;,
            &#39;size&#39; =&amp;gt; &#39;size_dir&#39;,
            &#39;type&#39; =&amp;gt; &#39;type_dir&#39;,
        ],
    ],
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also upload multiple files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39;,
    &#39;video&#39;
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;customizing-the-file-upload&quot;&gt;Customizing the file upload&lt;/h2&gt;

&lt;p&gt;CakePHP Upload does all the heavy-lifting using a new interface system. You can configure new classes to implement three key areas of file handling:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39; =&amp;gt; [
        // A pathProcessor handles both returning the basepath
        // as well as what the initial filename should be set to
        &#39;pathProcessor&#39; =&amp;gt; &#39;Josegonzalez\Upload\File\Path\DefaultProcessor&#39;

        // Allows you to create new files from the original source,
        // or possibly even modify/remove the original source file
        // from the upload process
        &#39;transformer&#39; =&amp;gt; &#39;Josegonzalez\Upload\File\Transformer\DefaultTransformer&#39;

        // Handles writing a file to disk... or S3... or Dropbox... or FTP... or /dev/null
        &#39;writer&#39; =&amp;gt; &#39;Josegonzalez\Upload\File\Writer\DefaultWriter&#39;,
    ],
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For anyone wondering, the above system allows us to do any of the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Handle arbitrary naming and pathing schemas&lt;/li&gt;
  &lt;li&gt;Add or remove original files to the upload&lt;/li&gt;
  &lt;li&gt;Extract video thumbnails&lt;/li&gt;
  &lt;li&gt;Add watermarks to files&lt;/li&gt;
  &lt;li&gt;Sanitize uploaded files&lt;/li&gt;
  &lt;li&gt;Write those files to anywhere &lt;a href=&quot;http://flysystem.thephpleague.com/&quot;&gt;Flysystem&lt;/a&gt; supports&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Want to create a thumbnail and upload both the original and your new file to S3? Install the AWS S3 Flysystem adapter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require league/flysystem-aws-s3-v3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And follow along as we rock your socks off&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$client = \Aws\S3\S3Client::factory([
    &#39;credentials&#39; =&amp;gt; [
        &#39;key&#39;    =&amp;gt; &#39;your-key&#39;,
        &#39;secret&#39; =&amp;gt; &#39;your-secret&#39;,
    ],
    &#39;region&#39; =&amp;gt; &#39;your-region&#39;,
    &#39;version&#39; =&amp;gt; &#39;latest&#39;,
]);
$adapter = new \League\Flysystem\AwsS3v3\AwsS3Adapter(
    $client,
    &#39;your-bucket-name&#39;,
    &#39;optional-prefix&#39;
);

$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39; =&amp;gt; [
        // Ensure the default filesystem writer writes using
        // our S3 adapter
        &#39;filesystem&#39; =&amp;gt; [
            &#39;adapter&#39; =&amp;gt; $adapter,
        ],

        // This can also be in a class that implements
        // the TransformerInterface or any callable type.
        &#39;transformer&#39; =&amp;gt; function (Table $table, Entity $entity, $data, $field, $settings) {
            // Store the thumbnail in a temporary file
            $tmp = tmpfile();

            // Use the Imagine library to DO THE THING
            $size = new \Imagine\Image\Box(40, 40);
            $mode = \Imagine\Image\ImageInterface::THUMBNAIL_INSET;
            $imagine = new \Imagine\Gd\Imagine();

            // Save that modified file to our temp file
            $imagine-&amp;gt;open($data[&#39;tmp_name&#39;])
                    -&amp;gt;thumbnail($size, $mode)
                    -&amp;gt;save($tmp);

            // Now return the original *and* the thumbnail
            return [
                $data[&#39;tmp_name&#39;] =&amp;gt; $data[&#39;name&#39;],
                $tmp =&amp;gt; &#39;thumbnail-&#39; . $data[&#39;name&#39;],
            ];
        },
    ],
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A list of methods needed to implement the proper interfaces &lt;a href=&quot;https://cakephp-upload.readthedocs.org/en/latest/interfaces.html&quot;&gt;are here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;things-yet-to-do&quot;&gt;Things yet to do&lt;/h2&gt;

&lt;p&gt;One thing that is sorely missing is upload file validation. Yes, you’re going to have to write these on your own. The Proffer plugin has these available, though in my mind the validation rules should be in their own plugin so &lt;em&gt;all&lt;/em&gt; upload plugins can benefit by just adding a &lt;code&gt;require&lt;/code&gt; statement to their &lt;code&gt;composer.json&lt;/code&gt;. Also, I’m lazy, and didn’t want to write a custom Validator class.&lt;/p&gt;

&lt;p&gt;Documentation is a bit sparse - the above docs are the first to show exactly how powerful the plugin can be - but that will be ameliorated over time.&lt;/p&gt;

&lt;h2 id=&quot;a-note-of-caution&quot;&gt;A note of caution&lt;/h2&gt;

&lt;p&gt;One thing I’d like to stress is that the less you do during a page request, the faster your response time will be and the more likely your users will use your site. Here’s a &lt;a href=&quot;http://searchengineland.com/googles-push-to-speed-up-your-web-site-42177&quot;&gt;helpful post&lt;/a&gt; on just how important that be to numbers like, idk, user retention and revenue.&lt;/p&gt;

&lt;p&gt;Given that information, I’d caution you against handling image manipulation etc. within a web request. This will work fine for some websites and internal administrative tools, but at some point you’re going to have to bite the bullet and refactor this code (and potentially even move the image uploading to outside of PHP entirely!). If only there was a way of combining file uploading and background processing…&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/05/uploading-files-and-images/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/05/uploading-files-and-images/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>upload</category>
        
        <category>files</category>
        
        <category>images</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>What exactly belongs in an entity?</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Sorry for the lateness, I was at a basketball game. The Nets lost against the Knicks, if anyone was wondering.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I’ve been in a few arguments about what an “entity” is. CakePHP 3 introduced them as a new way of representing a distinct set of data from a collection of “things”. Typically, that means a row in a table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$post = new Post;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a very long time, this was not how CakePHP abstracted information. You had an array, you modified an array, you saved an array, you deleted an array. GRONK WAS HAPPY!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.catster.com/wp-content/uploads/2015/06/RobGronkowski4.png&quot; alt=&quot;My cowork Rick O&#39;Hanlon&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Honestly though, the array stuff was quite annoying, and most (all?) CakePHP are happy we replaced them in CakePHP 3. The ORM changes that came along with it were… weird, but make sense once you think about them. But what exactly do I gain with an entity?&lt;/p&gt;

&lt;h2 id=&quot;custom-entity-data&quot;&gt;Custom Entity Data&lt;/h2&gt;

&lt;p&gt;An entity is a bag of data. It is a data bag. You put some data in it, and you can get that data out.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;breathe&lt;/em&gt; &lt;em&gt;plays anna nalick&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When you first use an entity, you should treat it as a dumb object. Previously, we would say “Fat Models, Skinny Controllers”. I think the same way about entities. Entities are fairly stupid. They know about themselves and not much else. That is to say, entities don’t and shouldn’t know how to save themselves, what it means to be a valid entity (save the mid-life crisis for a table), or really much of anything.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Entities are for holding data and virtually constructed data.&lt;/em&gt; If you have a &lt;code&gt;Post&lt;/code&gt; entity with information about a post, it may be able to constuct it’s published date, the number of views it has, or whether it is active or not, but it should &lt;em&gt;not&lt;/em&gt; know whether or not it is the latest version of a post, or whether it’s internal state is valid. These things should be left to tables and validators.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In the case of validators, they may change the state of an entity to add errors etc., but I don’t think of this as the state. The ORM will refuse to save an invalid entity, so really all you have is a bad bag of data that you need to clean up. The validation errors tell you how to do that.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;what-is-in-an-entity&quot;&gt;What is in an Entity?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-6d78XHD9qIQ/TsE7oLbG_nI/AAAAAAAAABE/XgB3ci9zv4o/s1600/Baby+names.jpg&quot; alt=&quot;No really, what the hell does an entity stand for?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We’ve always had “App” classes in PHP. What is an &lt;code&gt;App&lt;/code&gt; class? It’s literally a parent class that we use to contain some amount of default logic. You can create as many of these as you’d like. The &lt;code&gt;App&lt;/code&gt; prefix is just a standard, I like to call mine &lt;code&gt;Lolipop&lt;/code&gt;  classes when no one is looking.&lt;/p&gt;

&lt;p&gt;Here is my default &lt;code&gt;LolipopEntity&lt;/code&gt; class (hey, we have object oriented programming up in the hizouze!). You can place what you’d like in yours, I recommend seeing what is common and just doing that once:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Model\Entity;

use App\Model\Entity\Traits\JsonApi;
use Cake\ORM\Entity;

class LolipopEntity extends Entity
{
    use JsonApi;
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, that is cheating. You can see I include the &lt;code&gt;JsonApi&lt;/code&gt; trait, and here it is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Model\Entity\Traits;

use Cake\Routing\Router;
use Cake\Utility\Inflector;

trait JsonApi
{
    public static function className()
    {
        $classname = get_called_class();
        if (preg_match(&#39;@\\\\([\w]+)$@&#39;, $classname, $matches)) {
            $classname = $matches[1];
        }

        return $classname;
    }

    public function _getType()
    {
        $classname = static::className();
        return Inflector::classify($classname);
    }

    public function _getRoute()
    {
        $classname = static::className();

        return [
            &#39;controller&#39; =&amp;gt; Inflector::pluralize(Inflector::classify($classname)),
            &#39;action&#39; =&amp;gt; &#39;view&#39;,
            &#39;_method&#39; =&amp;gt; &#39;GET&#39;,
            &#39;id&#39; =&amp;gt; $this-&amp;gt;id,
        ];
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;JsonApi&lt;/code&gt; trait is something I use for building out APIs. My &lt;code&gt;AppEntity&lt;/code&gt; sometimes includes a &lt;code&gt;toArray&lt;/code&gt; that pulls in these false methods, or I include them manually in subclasses. I also have other related methods that build upon the data an entity has to create information &lt;em&gt;about&lt;/em&gt; that entity.&lt;/p&gt;

&lt;p&gt;Entities are bags of data, and while they are supposed to be stupid, in my view they should understand how to reference themselves. This is controversial amongst the core developers, but I take this stance because I like to keep my code DRY.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DONT REPEAT YOURSELF. Repeat after me (because I won’t!).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let’s say you have a database of events. Each event has a url, and you have custom routes for that url (to include seo information etc.). Each time you change the custom route, you may or may not have to change route information included to generate that route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;Html-&amp;gt;link(&#39;Awesome Event with Milkshakes&#39;, [
  &#39;controller&#39; =&amp;gt; &#39;Events&#39;,
  &#39;action&#39; =&amp;gt; &#39;view&#39;,
  &#39;id&#39; =&amp;gt; $entity-&amp;gt;id,
  &#39;slug&#39; =&amp;gt; $entity-&amp;gt;slug,
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At some point, writing the above out gets annoying. And while the reference to an object happens in the presentation layer and is probably easily done in a helper, isn’t it nice to do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;Html-&amp;gt;link(&#39;Awesome Event with Milkshakes&#39;, $entity-&amp;gt;getRoute());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The alternative is a helper to which you pass an entity, or always writing out the array.&lt;/p&gt;

&lt;h2 id=&quot;a-best-practice-or-at-least-a-practice&quot;&gt;A Best Practice, or at least a “Practice”&lt;/h2&gt;

&lt;p&gt;While I may disagree with the core developers on what goes where, we can all agree that at the end of the day, you should strive to write the least amount of code that works which won’t give you a headache at some other time. In my case, it is adding some presentational data to the &lt;code&gt;entity&lt;/code&gt; object. Maybe in your case, that means never using plugins or shirking away from namespaces.&lt;/p&gt;

&lt;p&gt;Remember, there are many ways to skin a cat (please don’t hurt my cat). So long as you aren’t increasing anyone’s cognitive load, choose the method that involves the least code.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live. - &lt;a href=&quot;http://c2.com/cgi/wiki?CodeForTheMaintainer&quot;&gt;Code For The Maintainer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 04 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/04/whats-in-an-entity/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/04/whats-in-an-entity/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>table</category>
        
        <category>entity</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Generating Administrative Panels with CrudView</title>
        <description>&lt;p&gt;Since time immemorial - okay, 2009 - it has been possible to set a custom view for CakePHP applications:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Don&#39;t try this, there isn&#39;t an ExcelView in the core :P
$this-&amp;gt;viewBuilder()-&amp;gt;className(&#39;ExcelView&#39;)
$this-&amp;gt;viewClass = &#39;ExcelView&#39;;

// Who remembers this from 1.x?
$this-&amp;gt;viewClass = &#39;MediaView&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since then, the number of view classes has increased dramatically, and we even have ways to map certain types of responses to particular view classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;RequestHandler-&amp;gt;config(&#39;viewClassMap&#39;, [
    // troll all your xml users
    &#39;xml&#39; =&amp;gt; &#39;Json&#39;,
    // this is from a plugin
    &#39;xlsx&#39; =&amp;gt; &#39;CakeExcel.Excel&#39;,
    // so is this!
    &#39;csv&#39; =&amp;gt; &#39;CsvView.Csv&#39;,
    // we are really into this plugin thing aren&#39;t we
    &#39;rss&#39; =&amp;gt; &#39;Feed.Rss&#39;
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the nice things about views is that they completely take over the rendering step, allowing you to create views that automatically generate interactive experiences. Similar to how the Crud plugin allows users to generate api responses, the CrudView plugin allows users to generate administrative panels.&lt;/p&gt;

&lt;h2 id=&quot;crudview&quot;&gt;CrudView&lt;/h2&gt;

&lt;p&gt;The CrudView plugin is actually one of the more difficult plugins to use, owing to the fact that there is basically zero documentation - we’re working on it! It works similar to how the Crud plugin does, using &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; options to lay everything out &lt;em&gt;just&lt;/em&gt; right.&lt;/p&gt;

&lt;p&gt;To start, you’ll want to install the bugger:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require friendsofcake/crud-view:dev-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The simplest method of using CrudView is to configure the Crud &lt;code&gt;listener&lt;/code&gt; and &lt;code&gt;viewClass&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Controller;

use Cake\Controller\Controller;
use Crud\Controller;
use Crud\Controller\ControllerTrait;

class AppController extends Controller
{
    use ControllerTrait;

    public function initialize()
    {
        parent::initialize();

        $this-&amp;gt;loadComponent(&#39;RequestHandler&#39;);
        $this-&amp;gt;loadComponent(&#39;Flash&#39;);

        // setup the viewclass
        $this-&amp;gt;viewBuilder()-&amp;gt;className(&#39;CrudView\View\CrudView&#39;)
        $this-&amp;gt;loadComponent(&#39;Crud.Crud&#39;, [
            &#39;actions&#39; =&amp;gt; [
                &#39;Crud.Index&#39;,
                &#39;Crud.Add&#39;,
                &#39;Crud.Edit&#39;,
                &#39;Crud.View&#39;,
                &#39;Crud.Delete&#39;,
            ],
            &#39;listeners&#39; =&amp;gt; [
                // and ensure we have the listener configured
                &#39;CrudView.View&#39;,
                &#39;Crud.RelatedModels&#39;,
                &#39;Crud.Redirect&#39;,
            ],
        ]);
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it! We now have automatic view scaffolding for every controller that inherits from the &lt;code&gt;AppController&lt;/code&gt;, &lt;em&gt;as well as&lt;/em&gt; all the yummy api stuff the Crud plugin gives us by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/03/admin.png&quot; alt=&quot;Crud View Admin&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hiding-sidebar-entries&quot;&gt;Hiding Sidebar Entries&lt;/h3&gt;

&lt;p&gt;CrudView is only as smart as you configure it to be. By default, it will show &lt;em&gt;all&lt;/em&gt; tables in the sidebar and link to their assumed administrative panels. I personally prefer not to show join tables, or anything related to database migrations, and as such my &lt;code&gt;AppController::beforeFilter&lt;/code&gt; looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function beforeFilter(Event $event)
{
    $this-&amp;gt;Crud-&amp;gt;action()-&amp;gt;config(&#39;scaffold.tables_blacklist&#39;, [
        &#39;blog_phinxlog&#39;,
        &#39;phinxlog&#39;,
        &#39;posts_tags&#39;,
    ]);

    return parent::beforeFilter($event);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/03/limit-sidebar.png&quot; alt=&quot;Crud View Admin&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;showing-specific-fields-for-specific-actions&quot;&gt;Showing specific fields for specific actions&lt;/h3&gt;

&lt;p&gt;On my index actions for Categories and Tags, I’d like to hide most fields and just show the &lt;code&gt;name&lt;/code&gt; field:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function beforeFilter(Event $event)
    if ($this-&amp;gt;request-&amp;gt;action == &#39;index&#39;) {
        $this-&amp;gt;Crud-&amp;gt;action()-&amp;gt;config(&#39;scaffold.fields&#39;, [&#39;name&#39;]);
    }
    return parent::beforeFilter($event);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/03/show-specific-fields.png&quot; alt=&quot;Showing specific fields&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Of note, you can also set these config options in specific actions, the same as you would to customize the crud plugin, but sometimes you can avoid that with very trivial hacks. I wouldn’t do the above if there was 10 lines of configuration for the IndexAction, for instance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;exposing-bulk-actions&quot;&gt;Exposing bulk actions&lt;/h3&gt;

&lt;p&gt;Sometimes I’d like to expose bulk post actions to my administrative users in a simple to use interface. CrudView takes a tact similar to wordpress and provides a checkboxes next to each row that can be used to “apply” configured actions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function initialize()
{
    parent::initialize();
    // map a fiew bulk actions
    $this-&amp;gt;Crud-&amp;gt;mapAction(&#39;deleteAll&#39;, &#39;Crud.Bulk/Delete&#39;);
    $this-&amp;gt;Crud-&amp;gt;mapAction(&#39;setStatus&#39;, [
        &#39;className&#39; =&amp;gt; &#39;Crud.Bulk/SetValue&#39;,
        &#39;field&#39; =&amp;gt; &#39;status&#39;,
    ]);
}
public function beforeFilter(Event $event)
{
    // provide the proper links to the actions
    $this-&amp;gt;Crud-&amp;gt;action()-&amp;gt;config(&#39;scaffold.bulk_actions&#39;, [
        Router::url([&#39;action&#39; =&amp;gt; &#39;deleteAll&#39;]) =&amp;gt; __(&#39;Delete selected&#39;),
        Router::url([&#39;action&#39; =&amp;gt; &#39;setStatus&#39;, &#39;status&#39; =&amp;gt; &#39;published&#39;]) =&amp;gt; __(&#39;Make published&#39;),
        Router::url([&#39;action&#39; =&amp;gt; &#39;setStatus&#39;, &#39;status&#39; =&amp;gt; &#39;pending-review&#39;]) =&amp;gt; __(&#39;Set to pending&#39;),
    ]);
    return parent::beforeFilter($event);
}

public function setStatus()
{
    $this-&amp;gt;_statusOptions = [
        &#39;published&#39; =&amp;gt; &#39;Published&#39;,
        &#39;pitch&#39; =&amp;gt; &#39;Pitch&#39;,
        &#39;assigned&#39; =&amp;gt; &#39;Assigned&#39;,
        &#39;in-progress&#39; =&amp;gt; &#39;In Progress&#39;,
        &#39;pending-review&#39; =&amp;gt; &#39;Pending Review&#39;,
    ];

    $value = $this-&amp;gt;request-&amp;gt;query(&#39;status&#39;);
    if (!in_array($value, array_keys($this-&amp;gt;_statusOptions))) {
        throw new BadRequestException(&#39;No valid status specified&#39;);
    }

    // ZHU LI, DO THE THING!
    $this-&amp;gt;Crud-&amp;gt;action()-&amp;gt;config(&#39;value&#39;, $value);
    return $this-&amp;gt;Crud-&amp;gt;execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/03/bulk-actions.png&quot; alt=&quot;Showing specific fields&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Obviously the logic here can get incredibly complex, and you are welcome to integrate both Crud and CrudView to best express these sorts of experiences for your users.&lt;/p&gt;

&lt;h2 id=&quot;youre-getting-sleepy&quot;&gt;You’re getting sleepy&lt;/h2&gt;

&lt;p&gt;Building administrative interfaces isn’t the most illustrious job out there, but if you ever find yourself in a pinch, the CrudView plugin is there to help. Hopefully the above will give you enough of a primer to find your way through the plugin, and we’ll continue plugging on it until it’s both polished and well-documented. Until tomorrow!&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Dec 2015 13:42:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/03/generating-administrative-panels-with-crud-view/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/03/generating-administrative-panels-with-crud-view/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>api</category>
        
        <category>crud</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Creating APIs using the CRUD Plugin</title>
        <description>&lt;p&gt;For anyone who has used CakePHP for the past 3 years, this will seem like kicking a dead horse, but here it is. The &lt;a href=&quot;https://github.com/friendsofcake/crud&quot;&gt;CRUD&lt;/a&gt; plugin is the finest way to rapidly build out apis in CakePHP, and certainly one of the best ways to do so in web application development.&lt;/p&gt;

&lt;p&gt;Lets say we were building an api for interacting with a blog. At the very least, we’d need the following controllers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tags&lt;/li&gt;
  &lt;li&gt;Categories&lt;/li&gt;
  &lt;li&gt;Posts&lt;/li&gt;
  &lt;li&gt;Users&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can use cake bake to create/recreate them as many times as you’d like, and you can customize your bake templates to do &lt;em&gt;exactly&lt;/em&gt; as you need. While this is certainly a fine approach, there are a few issues you’ll find with it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It is quite destructive to existing code, as it overwrites files.&lt;/li&gt;
  &lt;li&gt;All the generated code still needs tests.&lt;/li&gt;
  &lt;li&gt;While bake finally supports automatically generating api responses, these responses do not always conform to a “sane” format.&lt;/li&gt;
  &lt;li&gt;You are generating hundreds of lines of code which still need to be audited.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-typical-crud-application&quot;&gt;A typical CRUD Application&lt;/h2&gt;

&lt;p&gt;Here is a CRUD blog plugin I wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace Blog\Controller\Admin;

use Blog\Controller\AppController as BaseController;
use Cake\Event\Event;
use Crud\Controller\ControllerTrait;

class AppController extends BaseController
{
    use ControllerTrait;

    public function initialize()
    {
        parent::initialize();
        $this-&amp;gt;loadComponent(&#39;RequestHandler&#39;);
        $this-&amp;gt;loadComponent(&#39;Crud.Crud&#39;, [
            &#39;actions&#39; =&amp;gt; [
                &#39;Crud.Index&#39;,
                &#39;Crud.Add&#39;,
                &#39;Crud.Edit&#39;,
                &#39;Crud.View&#39;,
                &#39;Crud.Delete&#39;,
            ],
            &#39;listeners&#39; =&amp;gt; [
                &#39;Crud.RelatedModels&#39;,
                &#39;Crud.Redirect&#39;,
            ],
        ]);
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, that’s 30 lines of code that sets up all my basic actions, responds with json/xml/whatever I like, with full unit-test coverage. The underlying controllers are relatively simple as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace Blog\Controller\Admin;

use Blog\Controller\Admin\AppController;

class PostsController extends AppController
{
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it feels like cheating, that’s because it is. But this isn’t an exam, and you have better things to do than worry about the minute details of &lt;code&gt;public function add&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;custom-actions&quot;&gt;Custom Actions&lt;/h2&gt;

&lt;p&gt;One complaint about the CRUD plugin is that it seems limited to just CRUD-actions, and doesn’t seem to be easy to extend. Both of these are patently false.&lt;/p&gt;

&lt;p&gt;The CRUD plugin comes with 5 different base action classes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;CreateAction&lt;/code&gt;: Create an entity.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DeleteAction&lt;/code&gt;: Delete an entity.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EditAction&lt;/code&gt;: Edit a single entity.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ViewAction&lt;/code&gt;: View a single entity.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IndexAction&lt;/code&gt;: List many entities via pagination.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we also have 3 special actions for dealing with entities in bulk:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;BulkDeleteAction&lt;/code&gt;: Delete one or more entities at once&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;BulkSetValueAction&lt;/code&gt;: Set a value for many entities at the same time&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;BulkToggleAction&lt;/code&gt;: Toggle boolean fields for many entities at once&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is even a special action for the &lt;a href=&quot;https://github.com/friendsofcake/crud-view&quot;&gt;Crud-View&lt;/a&gt; plugin:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;LookupAction&lt;/code&gt;: Displays a record from a data source for auto-complete purposes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While the names of these actions is set in stone, it is easy to imagine yourself creating an action for scoping certain fields for editing by a post submitter, and then giving an editor even more control. This is done through the use of custom CakePHP events like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function add()
{
    $this-&amp;gt;Crud-&amp;gt;on(&#39;beforeSave&#39;, function(\Cake\Event\Event $event) {
        // do whatever you want with the event-&amp;gt;subject and data
    });
    // continue on with the rest of the action
    return $this-&amp;gt;Crud-&amp;gt;execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The awesome thing about the CRUD plugin is that it is quite easy to create single-purpose actions for your own use. For instance, a recent plugin I was contracted to do has a custom &lt;code&gt;AutocompleteAction&lt;/code&gt; that integrates with &lt;a href=&quot;https://brianreavis.github.io/selectize.js/&quot;&gt;selectize.js&lt;/a&gt; to handle tagging. I’ve also created similar actions for Login/Logout.&lt;/p&gt;

&lt;h2 id=&quot;going-further&quot;&gt;Going Further&lt;/h2&gt;

&lt;p&gt;While CRUD does simplify a ton of work around creating APIs for applications, many applications &lt;em&gt;also&lt;/em&gt; need administrative panels for users who don’t want to use &lt;code&gt;curl&lt;/code&gt; to interact with your websites. Thankfully, the &lt;a href=&quot;https://github.com/friendsofcake/crud-view&quot;&gt;&lt;code&gt;Crud-View&lt;/code&gt;&lt;/a&gt; plugin is available for just such purposes, and we’ll cover it’s use tomorrow.&lt;/p&gt;

&lt;p&gt;Bonus: Read this lovely tutorial on adding &lt;a href=&quot;http://www.bravo-kernel.com/2015/04/how-to-add-jwt-authentication-to-a-cakephp-3-rest-api/&quot;&gt;JWT Auth to a Crud application&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Dec 2015 13:42:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/02/creating-apis-using-the-crud-plugin/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/02/creating-apis-using-the-crud-plugin/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>api</category>
        
        <category>crud</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Using Fractal to transform entities for custom api endpoints</title>
        <description>&lt;p&gt;In a CakePHP 3 application, you can very easily create Apis with entity objects. Each entity implements the &lt;code&gt;JsonSerializable&lt;/code&gt; interface, and you can customize the output by creating a custom &lt;code&gt;toArray()&lt;/code&gt; method (or &lt;code&gt;jsonSerialize()&lt;/code&gt; if you want to skip a step):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Model\Entity;
use Cake\ORM\Entity;
use Cake\Routing\Router;

class Post extends Entity
{
    public function toArray()
    {
        // Special logic goes here
        $data = parent::toArray();
        return $data;
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you serialized a set of these entities, you would have something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  [{
    &quot;id&quot;: 6,
    &quot;title&quot;: &quot;Herp derpes&quot;,
    &quot;year&quot;: null
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not great, especially if this serialization changes from endpoint to endpoint.&lt;/p&gt;

&lt;p&gt;A few months ago, it was requested that there be a way to define endpoint-specific entity serialization, which is difficult with the above type of setup. There are a few methods to go about such a thing, one of which is to use a custom View class that will automatically wrap entities.&lt;/p&gt;

&lt;h2 id=&quot;fractal&quot;&gt;Fractal&lt;/h2&gt;

&lt;p&gt;Fractal is a php package by The PHP League whose description is as follows:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Fractal provides a presentation and transformation layer for complex data output, the like found in RESTful APIs, and works really well with JSON. Think of this as a view layer for your JSON/YAML/etc.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Isn’t that nice? Using fractal, we can write wrappers around arbitrary inputs and have arbitrary outputs. Fractal supports quite a few types of &lt;a href=&quot;http://fractal.thephpleague.com/transformers/&quot;&gt;transformations&lt;/a&gt; and &lt;a href=&quot;http://fractal.thephpleague.com/serializers/&quot;&gt;serializers&lt;/a&gt;, so be sure to check them out.&lt;/p&gt;

&lt;p&gt;Note that we &lt;em&gt;could&lt;/em&gt; have created our own data-wrapping library, but why bother? We can and should use pre-existing libraries wherever possible for several reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The code is (hopefully) better tested&lt;/li&gt;
  &lt;li&gt;It may provide additional features you have not yet thought of&lt;/li&gt;
  &lt;li&gt;More mindshare can sometimes mean easier onboarding of developers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Similar to how we shouldn’t re-invent a framework for work purposes, we should also strive for code re-use wherever it is feasible. In our case, The PHP League provides &lt;a href=&quot;https://thephpleague.com/&quot;&gt;quite a few delicious libraries&lt;/a&gt; (in some cases similar to those provided by CakePHP itself!) we can sprinkle around our CakePHP application.&lt;/p&gt;

&lt;h2 id=&quot;fractalentities&quot;&gt;FractalEntities&lt;/h2&gt;

&lt;p&gt;Rather than have to build such integrations over and over, I built a single-purpose plugin for this case. As the use-case was very simple, it doesn’t have many options - nor docs for that matter - but this post should serve as a good example of how to use it going forward.&lt;/p&gt;

&lt;p&gt;In our case, we’re going to use a wrapper plugin called FractalEntities to create a nicer-version of the json output that looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;data&quot;: [{
    &quot;id&quot;: 6,
    &quot;title&quot;: &quot;Herp derpes&quot;,
    &quot;year&quot;: null,
    &quot;links&quot;: [{
      &quot;rel&quot;: &quot;self&quot;,
      &quot;uri&quot;: &quot;\/blog\/post-1&quot;
    }]
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, lets start out by installing the plugin using composer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;composer require josegonzalez/cakephp-fractal-entities
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will install our wrapper &lt;code&gt;TransformerView&lt;/code&gt; class which does the heavy lifting.&lt;/p&gt;

&lt;p&gt;The simplest setup will be to set the current &lt;code&gt;Controller::$viewClass&lt;/code&gt; to the &lt;code&gt;TransformerView&lt;/code&gt; and set your data for serialization:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;viewBuilder()-&amp;gt;className(&#39;FractalEntities.Transformer&#39;)
$this-&amp;gt;set(&#39;_serialize&#39;, &#39;posts&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we will define a transformer class. The namespace of each transformer class is interpolated based upon the current request path like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// if you are missing any param, assume you don&#39;t
// need that section in the class namespace
$path = array_filter([
    &#39;App&#39;,
    &#39;Transformer&#39;,
    $this-&amp;gt;request-&amp;gt;param(&#39;plugin&#39;),
    $this-&amp;gt;request-&amp;gt;param(&#39;prefix&#39;),
    $this-&amp;gt;request-&amp;gt;param(&#39;controller&#39;),
    $this-&amp;gt;request-&amp;gt;param(&#39;action&#39;) . &#39;Transformer&#39;,
], &#39;strlen&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For &lt;code&gt;/posts/view/1&lt;/code&gt; - assuming no plugins or prefixes - you will need the following file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src/Transformer/Posts/ViewTransformer.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with the following class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Transformer\Posts;

use App\Model\Entity\Post;
use League\Fractal\TransformerAbstract;

class IndexTransformer extends TransformerAbstract
{
    /**
     * Creates a response item for each instance
     *
     * @param Post $post post entity
     * @return array transformed post
     */
    public function transform(Post $post)
    {
        return [
            &#39;id&#39; =&amp;gt; (int)$post-&amp;gt;get(&#39;id&#39;),
            &#39;title&#39; =&amp;gt; $post-&amp;gt;get(&#39;title&#39;),
            &#39;year&#39; =&amp;gt; $post-&amp;gt;get(&#39;published_date&#39;),
            &#39;links&#39; =&amp;gt; [
                [
                    &#39;rel&#39; =&amp;gt; &#39;self&#39;,
                    &#39;uri&#39; =&amp;gt; &#39;/books/&#39; . $post-&amp;gt;get(&#39;route&#39;),
                ]
            ],
        ];
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All transformers will need a &lt;code&gt;transform&lt;/code&gt; method, which will take a single entity of whatever type you are turning into an api response. Note that due to our use of Fractal, we can be sure that whether we are converting a single entity or an entire resultset, the response will always be converted properly.&lt;/p&gt;

&lt;h2 id=&quot;is-this-best-practice&quot;&gt;Is this “best practice”?&lt;/h2&gt;

&lt;p&gt;The answer to that is “maybe”. Perhaps for your application, separating the presentation layer from your entity layer will work out really well due to the myriad of ways data can be represented. This might also result in a lot of extra classes that are harder to navigate, or extra magic that may be difficult to understand later.&lt;/p&gt;

&lt;p&gt;One nice thing about this method is that it is quite easy to separate presentation-layer unit tests from those relating to the entity itself. Because the entity is being wrapped away from where your business logic is located, it’s much easier to reason about how the output itself.&lt;/p&gt;

&lt;p&gt;Tomorrow I’ll show you a powerful alternative for json api creation.&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Dec 2015 13:42:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/01/using-fractal-to-transform-entities-for-custom-api-endpoints/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/01/using-fractal-to-transform-entities-for-custom-api-endpoints/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>api</category>
        
        <category>entities</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Sending email invoices to users on payment</title>
        <description>&lt;p&gt;Once a user has made a purchase, they will likely want some sort of proof that the purchase went through. We can send them an email at every step of the way. We’ll start by sending an email as soon as the purchase was completed.&lt;/p&gt;

&lt;p&gt;CakePHP’s email system allows us to use Templates to send email. We previously briefly covered email sending while building the anonymous issue tracker - though simply using raw messages. CakePHP is capable of sending messages both as plaintext and as html, and is also capable of wrapping emails in layouts. Here is a simple, contrived example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Load the class at the top of your class using the `use` statement
use Cake\Network\Email\Email;
// Construct an email object
$email = new Email();
// Send the email using the template in `src/Template/Email/TYPE/herp.ctp`
// and the layout in `src/Template/Layout/Email/TYPE/derp.ctp`
// Type is the type of the message
$email-&amp;gt;template(&#39;herp&#39;, &#39;derp&#39;);
// Send the email as a multi-part type message, both as `text` and `html`.
// This means that the previous `template` call configures 4 different
// files for use when sending
$email-&amp;gt;emailFormat(&#39;both&#39;);
// Send the email to this user
$email-&amp;gt;to(&#39;camilla@number1.com&#39;);
// Specify this user to send as
$email-&amp;gt;from(&#39;app@domain.com&#39;);
// Actually send the email!
$email-&amp;gt;send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we are going to do is send a simple, plain-text email that uses a text template and a text layout. Let’s start by creating a &lt;code&gt;src/Template/Email/text/purchase.ctp&lt;/code&gt; file with the following contents:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;Hi!
We&#39;re messaging you to let you know someone made a purchase for &amp;lt;?= $amount ?&amp;gt; at &amp;lt;?= $purchase_time ?&amp;gt; under the email &amp;lt;?= $user[&#39;email&#39;] ?&amp;gt;. If this seems incorrect, let us know!
The following items were purchased:
&amp;lt;?php foreach ($order_items as $order_item) :?&amp;gt;
- &amp;lt;?= $order_item-&amp;gt;product-&amp;gt;name ?&amp;gt;: $&amp;lt;?= $order_item-&amp;gt;price ?&amp;gt;
&amp;lt;?php endforeach; ?&amp;gt;
If you have any questions, feel free to respond to this email!
- Awesome Store
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;While we won’t modify the default text layout, please note that the default CakePHP layouts contain a message stating that the email was sent from the CakePHP framework. You can remove these if you like&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now that we have our email set, lets create a new event in our &lt;code&gt;app/config/events.php&lt;/code&gt; that we can use to send the email. We’ll call it &lt;code&gt;Order.postPurchase&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;use Cake\Network\Email\Email;
EventManager::instance()-&amp;gt;attach(function (Event $event) {
  $amount = $event-&amp;gt;data[&#39;amount&#39;];
  $order_items = $event-&amp;gt;data[&#39;order&#39;]-&amp;gt;order_items;
  $purchase_time = date(&#39;Y-m-d H:i:s&#39;);
  $user = $event-&amp;gt;data[&#39;user&#39;];
  $email = new Email();
  $email-&amp;gt;template(&#39;purchase&#39;, &#39;default&#39;)
      -&amp;gt;emailFormat(&#39;text&#39;)
      -&amp;gt;to($user[&#39;email&#39;])
      -&amp;gt;from(&#39;store@example.com&#39;)
      -&amp;gt;viewVars(compact(&#39;amount&#39;, &#39;order_items&#39;, &#39;purchase_time&#39;, &#39;user&#39;))
      -&amp;gt;send();
}, &#39;Order.postPurchase&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we’ll ensure we actually trigger this event in our &lt;code&gt;checkout&lt;/code&gt; action. Modify the bake &lt;code&gt;checkout.ctp&lt;/code&gt; element to include the following when the &lt;code&gt;$response-&amp;gt;isSuccessful()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$event = new \Cake\Event\Event(&#39;Order.postPurchase&#39;, $this, [
    &#39;amount&#39; =&amp;gt; $amount,
    &#39;order&#39; =&amp;gt; $order,
    &#39;user&#39; =&amp;gt; $this-&amp;gt;Auth-&amp;gt;user(),
]);
\Cake\Event\EventManager::instance()-&amp;gt;dispatch($event);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll need configure your email settings in &lt;code&gt;app/config/app.php&lt;/code&gt;, but once you do, we will be sending users email whenever they’ve successfully completed a purchase! Note that now that we are using templates, we can &lt;em&gt;also&lt;/em&gt; use helpers as you would in any other template file, which allows you to build more complex emails and drive campaigns to users.&lt;/p&gt;

&lt;h2 id=&quot;homework-time&quot;&gt;Homework Time&lt;/h2&gt;

&lt;p&gt;You can actually do a few cool things with email - that I’ve done in other CakePHP websites and other frameworks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Log all emails to CLI and the Database when in Debug mode so that you can view what &lt;em&gt;would&lt;/em&gt; have been sent to a user instead of potentially spamming users. CakePHP allows you to build arbitrary Transport classes to make this possible.&lt;/li&gt;
  &lt;li&gt;Make a PostPurchaseEmail class that can take all it’s configuration within the constructor. This way you can simply instantiate that particular email class and let it worry about how it should configure the email.&lt;/li&gt;
  &lt;li&gt;Send both an html and a text representation of the same email. &lt;a href=&quot;http://templates.mailchimp.com/&quot;&gt;Mailchimp provides some templates&lt;/a&gt; you can model your email layouts after to get wider email client support.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Be sure to follow along via twitter on &lt;a href=&quot;https://twitter.com/savant&quot;&gt;@savant&lt;/a&gt;. If you’d like to subscribe to this blog, you may follow the &lt;a href=&quot;http://josediazgonzalez.com/atom.xml&quot;&gt;rss feed here&lt;/a&gt;. Also, all posts in the series will be conveniently linked on the sidebar of every post in the 2014 CakeAdvent Calendar. Come back tomorrow for more delicious content.&lt;/p&gt;

</description>
        <pubDate>Mon, 15 Dec 2014 13:42:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2014/12/15/sending-email-invoices-to-users-on-payment/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2014/12/15/sending-email-invoices-to-users-on-payment/</guid>
        
        <category>cakeadvent-2014</category>
        
        <category>cakephp</category>
        
        <category>email</category>
        
        <category>templates</category>
        
        
        <category>cakephp</category>
        
      </item>
    
  </channel>
</rss>
